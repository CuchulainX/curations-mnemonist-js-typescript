import {Head} from 'mdx-deck';
import WideLayout, {WideLayoutWithSmallCode} from './components/WideLayout';
import MainTitle, {MainTitleBis} from './components/MainTitle';
import Title from './components/Title';
import styled from 'styled-components';
export theme from './theme';

<Head>
  <title>FOSDEM 2019 - Developing data structures for JavaScript</title>
  <link href="https://fonts.googleapis.com/css?family=Muli:900" rel="stylesheet" />
</Head>

<MainTitle />

<small>JavaScript devroom, FOSDEM 2019, Brussels</small>

---

## Why and how to implement efficient data structures to use with node.js or in the browser?

---

## Who am I?

*Guillaume Plique*

alias `Yomguithereal` on both [Github](https://github.com/Yomguithereal) an [Twitter](https://twitter.com/Yomguithereal).

Research engineer working for Sciences Po's [médialab](https://medialab.sciencespo.fr).

---

## What's a data structure?

---

> «Web development is not real development and is henceforth easier.»

<div style={{textAlign: 'right'}}>
  <small>
    Someone wrong on the Internet.
  </small>
</div>

---

> «Web development is trivial and web developers don't need fancy data structures or any solid knowledge in algorithmics.»

<div style={{textAlign: 'right'}}>
  <small>
    Someone still wrong (and pedant) on the Internet.
  </small>
</div>

---

### Don't we already have fully satisfying data structures in JavaScript?

* `Array` ➡ lists of things
* `Object` ➡ key-value associations
* `Map` and `Set` with ES6

---

### Why would we want other data structures in JavaScript?

---

<MainTitleBis />

<small>JavaScript devroom, FOSDEM 2019, Brussels</small>

---

<Title affix="1.">Why?</Title>

---

<Title affix="1.1.">Convenience and bookkeeping</Title>

---

export default WideLayout

<Title affix="1.1.1." level={3}>A MultiSet</Title>

```js
// How about changing this:
const counts = {};

for (const item in something) {
  if (!(item in counts))
    counts[item] = 0;

  counts[item]++;
}
```

```js
// Into this:
const counts = new MultiSet();

for (const item in something)
  counts.add(item);
```

---

export default WideLayout

```js
// And what about this?
const counts = {};

for (const item in something) {
  if (!(item.key in counts))
    counts[item.key] = 0;

  counts[item.key] += item.value;

  // But value CAN be negative
  // and you don't want to keep items < 0
  if (counts[item.key] < 0)
    delete counts[item.key];
}
```

---

export default WideLayout

```js
// Still this:
const counts = new MultiSet();

for (const item in something)
  counts.add(item.value);
```

---

<Title affix="1.1.2." level={3}>Complex structures: a Graph</Title>

Sure, you can "implement" graphs using only `Array` and `Object`™.

But:

* Lots of bookkeeping (multi-way indexation)
* Wouldn't it be nice to have a legible interface?

---

Examples taken from the [graphology](https://graphology.github.io/) library:

```js
const graph = new Graph();

// Finding specific neighbors
const neighbors = graph.outNeighbors(node);

// Iterating over a node's edges
graph.forEachEdge(node, (edge, attributes) => {
  console.log(attributes.weight);
});
```

---

<Title affix="1.2.">Sometimes Arrays and Objects are not enough</Title>

---

<Title affix="1.2.1." level={3}>The QuadTree</Title>

![Quad](./img/quad.svg)

---

<Title affix="1.2.1." level={3}>The QuadTree</Title>

![QuadTree](./img/quadtree.svg)

---

<Title affix="1.2.2." level={3}>JavaScript became more than just tacky website candy</Title>

* We process data on the client nowadays.
* Node.js became a thing.
* Some algorithms cannot be efficiently implemented without custom data structures (Dijkstra or Inverted Index for full text search etc.).

---

<Title affix="1.3.">Immutable data structures</Title>

* Not *yet* in JavaScript.
* Not covered by this talk.
* Check out [mori](https://github.com/swannodette/mori) and [immutable-js](https://facebook.github.io/immutable-js/).

---

<Title affix="2.">What are the challenges?</Title>

---

<Title affix="1." level={3}>Interpreted languages are far from the metal</Title>

---

<Title affix="2." level={3}>No control over memory layout &amp; garbage collection</Title>

---

<Title affix="3." level={3}>JIT and optimizing engines such as Gecko and V8</Title>

---

TL,DR:<br />Benchmarking code accurately is **not** easy.

---

<Title affix="3.">Implementation tips</Title>

It does not mean we cannot be clever about it.

---

<Title affix="3.1." level={3}>Time &amp; memory performance</Title>

---

<Title affix="3.1.1." level={3}>Minimizing lookups</Title>

"Hashmap" lookups are costly.

```js
// You made 2 lookups
Graph.prototype.getNodeAttribute = function(node, data) {
  if (this._nodes.has(node))
    throw Error(...);

  const data = this._nodes.get(node);

  return data[name];
};
```

---

```js
// You made only one
Graph.prototype.getNodeAttribute = function(node, data) {
  const data = this._nodes.get(node);

  if (typeof data === 'undefined')
    throw Error(...);

  return data[name];
};
```

---

<Title affix="3.1.2." level={3}>Creating objects is costly</Title>

* Avoid allocating objects.
* Avoid creating regexes.
* Functions are even worse.

```js
// BAD!
const test = x => /regex/.test(x);

// GOOD!
const REGEX = /regex/;
const test = x => REGEX.test(x);
```

---

export default WideLayout

<Title affix="3.1.3." level={3}>Mixing types is bad</Title>

```js
// Why do you do that?
const array = [1, 'two', 3, /four/];
```
---

<Title affix="3.1.4." level={3}>The poor man's malloc</Title>

* Bytes array are fan-ta-stic.
* You can simulate typed allocation: `Uint8Array`, `Float32Array` etc.
* Use this to implement your own pointer system!

---

export default WideLayout

```txt
A linked list (with pointers):
------------------------------
head -> (a) -> (b) -> (c) -> ø
```

```js
// Using object references as pointers
function LinkedListItem(value) {
  this.left = null;
  this.right = null;
  this.value = value;
}
```

---

export default WideLayout

```txt
A linked list (rolling our own pointers):
-----------------------------------------
head     = 0
values   = [a, b, c]
next     = [1, 2, 0]
```

```js
// Using Byte Arrays
function LinkedList(capacity) {
  this.head = 0;
  this.next = new Uint16Array(capacity);
  this.values = new Array(capacity);
}
```

---

<Title level={3}>A most efficient LRUCache</Title>

```js
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;

    this.forwardPointers = new Uint32Array(capacity);
    this.backwardPointers = new Unit32Array(capacity);
    this.keys = new Array(capacity);
    this.values = new Array(capacity);

    this.items = {};

    this.size = 0;
    this.head = 0;
    this.tail = 0;
  }
}
```

---

<Title affix="3.1.4." level={3}>Function calls are costly</Title>

Everything is costly. Really.

This means that rolling your own stack will always beat recursion.

---

export default WideLayout

```js
// Recursive version
function recurse(node, key) {
  if (key < node.value) {
    if (node.left)
      return recurse(node.left, key);

    return false;
  }
  else if (key > node.value) {
    if (node.right)
      return recurse(node.right, key);

    return false;
  }

  return true;
}
```

---

export default WideLayoutWithSmallCode

```js
// Iterative version
function iterative(root, key) {
  const stack = [root];

  while (stack.length) {
    const node = stack.pop();

    if (key < node.value) {
      if (node.left)
        stack.push(node.left);
      else
        break;
    }
    else if (key > node.value) {
      if (node.right)
        stack.push(node.right);
      else
        break;
    }

    return true;
  }
}
```

---

<Title affix="3.1.5." level={3}>Algorithmics vs. the real world</Title>

A better big O is not necessary better in the real world.

Dijkstra requires a Fibonacci heap, but in JavaScript, a binomial heap will often win.

---

<Title affix="3.1.6." level={3}>What about wasm etc. ?</Title>

Lots of shiny options:

1. asm.js
2. WebAssembly
3. Native code binding in Node.js

---

<Title affix="3.1.6." level={3}>What about wasm etc. ?</Title>

Communication between those and JavaScript has a cost that negates the benefit.

This is only viable if you have long running code or don't need the bridge between the layer and JavaScript.

---

<Title affix="3.2." level={3}>Respecting the ecosystem</Title>

---

<Title affix="3.2.1." level={3}>Naming matters</Title>

Yes `#.unshift` is a terrible name. <small className="very-small">I am still grateful we avoided smooshing arrays.</small>

But consistency is always a plus.

---

<Title affix="3.2.1." level={3}>Implement well-known interfaces</Title>

```js
// Handling JSON serialization
Structure.prototype.toJSON = function() {
  return this.items;
};

JSON.stringify(structure);
>>> ['something', 'easily', 'serializable']

Structure.prototype.toString = function() {
  return somethingUsefulForOnce;
};
```

---

export default WideLayout

<Title affix="3.2.2." level={3}>Make structure iterables</Title>

```js
// Implement #.forEach "iterators"
queue.forEach(item => console.log(item));

// Implement the iterator protocol
Queue.prototype.values = function() {

  return {
    next: function() {
      // ...
      return {
        done: false,
        value: whatever
      };
    }
  };
};
```

---

export default WideLayout

<Title affix="3.2.2." level={3}>Make structure iterables</Title>

```js
// Make objects iterable
Queue.prototype[Symbol.iterator] = Queue.prototype.values;

// Behold the future!
for (const item of queue) {
  console.log(item);
}
```

---

<Title affix="3.2.3." level={3}>Custom Node.js inspection</Title>

```js
// Earlier (now Symbol.for('nodejs.util.inspect.custom'))
Queue.prototype.inspect = function() {
  return somethingUseful;
};

console.log(queue);
>>> Queue [1, 2, 3]

// Rather than:
>>> {
  size: 1,
  __items: [5, 1, 4],
  __someVeryVeryPrivateAndUglyName: true
}
```

---

<Title affix="4.">Parting words</Title>

---

<Title affix="4.1." level={3}>Yes, optimizing JavaScript is hard.</Title>

---

<Title affix="4.2." level={3}>But it does not mean we cannot do it.</Title>

---

<Title affix="4.3." level={3}>Most tips are applicable to every high-level languages.</Title>

---

<Title affix="4.4." level={3}>But JavaScript has its idiosyncrasies</Title>

The `ByteArray` tips absolutely don't work in python.

It's even slower if you use `numpy` arrays. (you need to go full native).

---

<Title level={3}>The gist</Title>

To be efficient your code must be **statically interpretable**.

If you do that:

1. The engine will have **no hard decisions** to make
2. And will safely choose the most aggressive optimization paths

---

<Title level={3}>Rephrased</Title>

Optimizing JavaScript = squinting a little and **pretending** really hard that:

1. The language has static typing.
2. That the language is low-level.

---

<Title affix="4.5." level={3}>Associative arrays are the next frontier</Title>

For now, there is no way to beat JavaScript's objects and maps when doing key-value association.

*Yet...*

---

<Title affix="5.">References</Title>

Examples were taken from the following libraries:

* [mnemonist](https://yomguithereal.github.io/mnemonist): <small><em>yomguithereal.github.io/mnemonist</em></small>
* [graphology](https://graphology.github.io): <small><em>graphology.github.io</em></small>
* [sigma.js](http://sigmajs.org): <small><em>sigmajs.org</em></small>

---

# Thanks!
