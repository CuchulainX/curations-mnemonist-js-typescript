import {Head} from 'mdx-deck';
import WideLayout from './components/WideLayout';
import MainTitle, {MainTitleBis} from './components/MainTitle';
import Title from './components/Title';
import styled from 'styled-components';
export theme from './theme';

<Head>
  <title>FOSDEM 2019 - Developing data structures for JavaScript</title>
  <link href="https://fonts.googleapis.com/css?family=Muli:900" rel="stylesheet" />
</Head>

<MainTitle />

<small>JavaScript devroom, FOSDEM 2019, Brussels</small>

---

## Why and how to implement efficient data structures to use with node.js or in the browser?

---

## Who am I?

*Guillaume Plique*

alias `Yomguithereal` on both [Github](https://github.com/Yomguithereal) an [Twitter](https://twitter.com/Yomguithereal).

Research engineer working for Sciences Po's [médialab](https://medialab.sciencespo.fr).

---

## What's a data structure?

---

> «Web development is not real development and is henceforth easier.»

<div style={{textAlign: 'right'}}>
  <small>
    Someone wrong on the Internet.
  </small>
</div>

---

> «Web development is trivial and web developers don't need fancy data structures or any solid knowledge in algorithmics.»

<div style={{textAlign: 'right'}}>
  <small>
    Someone still wrong (and pedant) on the Internet.
  </small>
</div>

---

### Don't we already have fully satisfying data structures in JavaScript?

* `Array` ➡ lists of things
* `Object` ➡ key-value associations
* `Map` and `Set` with ES6

---

### Why would we want other data structures in JavaScript?

---

<MainTitleBis />

<small>JavaScript devroom, FOSDEM 2019, Brussels</small>

---

<Title affix="1.">Why?</Title>

---

<Title affix="1.1.">Convenience and bookkeeping</Title>

---

export default WideLayout

<Title affix="1.1.1." level={3}>A MultiSet</Title>

```js
// How about changing this:
var counts = {};

for (var item in something) {
  if (!(item in counts))
    counts[item] = 0;

  counts[item]++;
}
```

```js
// Into this:
var counts = new MultiSet();

for (var item in something)
  counts.add(item);
```

---

export default WideLayout

```js
// And what about this?
var counts = {};

for (var item in something) {
  if (!(item.key in counts))
    counts[item.key] = 0;

  counts[item.key] += item.value;

  // But value CAN be negative
  // and you don't want to keep items < 0
  if (counts[item.key] < 0)
    delete counts[item.key];
}
```

---

export default WideLayout

```js
// Still this:
var counts = new MultiSet();

for (var item in something)
  counts.add(item.value);
```

---

<Title affix="1.1.2." level={3}>Complex structures: a Graph</Title>

Sure, you can "implement" graphs using only `Array` and `Object`™.

But:

* Lots of bookkeeping (multi-way indexation)
* Wouldn't it be nice to have a legible interface?

---

Examples taken from the [graphology](https://graphology.github.io/) library:

```js
const graph = new Graph();

// Finding specific neighbors
const neighbors = graph.outNeighbors(node);

// Iterating over a node's edges
graph.forEachEdge(node, (edge, attributes) => {
  console.log(attributes.weight);
});
```

---

<Title affix="1.2.">Sometimes Arrays and Objects are not enough</Title>

---

<Title affix="1.2.1." level={3}>The QuadTree</Title>

<img src="./img/quad.svg" />

---

<Title affix="1.2.1." level={3}>The QuadTree</Title>

<img src="./img/quadtree.svg" />

---

<Title affix="1.2.2." level={3}>JavaScript became more than just tacky website candy</Title>

* We process data on the client nowadays.
* Node.js became a thing.
* Some algorithms cannot be efficiently implemented without custom datastructures (Dijkstra e.g. etc.).

---

<Title affix="1.3.">Immutable data-structures</Title>

* Not *yet* in JavaScript.
* Not covered by this talk.
* Check out [mori](https://github.com/swannodette/mori) and [immutable-js](https://facebook.github.io/immutable-js/).

---

<Title affix="2.">What are the challenges?</Title>

---

<Title affix="1." level={3}>Interpreted languages are far from the metal</Title>

---

<Title affix="2." level={3}>No control over memory layout &amp; garbage collection</Title>

---

<Title affix="3." level={3}>JIT and optimizing engines such as Gecko and V8</Title>

---

TL,DR:<br />Benchmarking code accurately is **not** easy.

---

<Title affix="3.">Implementation tips</Title>

It does not mean we cannot be clever about it.

---

<Title affix="3.1." level={3}>Time &amp; memory performance</Title>

---

1. minimize lookups
2. avoid creating objects & functions
3. Pointers malloc du pauvre
3. object vs. map
4. cost of function cost -> using stacks to simulate recursion
5. asm

---

<Title affix="3.2." level={3}>Respecting the ecosystem</Title>

---

<Title affix="3.2.1." level={3}>Naming matters</Title>

Yes `#.unshift` is a terrible name. <small className="very-small">I am still grateful we avoided smooshing arrays.</small>

But consistency is always a plus.

---

<Title affix="3.2.1." level={3}>Implement well-known interfaces</Title>

```js
// Handling JSON serialization
Structure.prototype.toJSON = function() {
  return this.items;
};

JSON.stringify(structure);
>>> ['something', 'easily', 'serializable']

Structure.prototype.toString = function() {
  return somethingUsefulForOnce;
};
```

---

<Title affix="3.2.1." level={3}>Make structure iterable</Title>

```js
queue.forEach(item => console.log(item));
```

---

iterables & forEach, util.inspect, toString, toJSON

1. unshift shenaningans
2. Iterables, forEach, inspection in node

---

<Title affix="4.">Parting words</Title>

---

<Title affix="4.1." level={3}>Yes, optimizing JavaScript is hard.</Title>

---

<Title affix="4.2." level={3}>But it does not mean we cannot do it.</Title>

---

<Title affix="4.3." level={3}>Most tips are applicable to every high-level languages.</Title>

---

<Title affix="4.4." level={3}>But JavaScript has its idiosyncrasies</Title>

The `ByteArray` tips absolutely don't work in python.

It's even slower if you use `numpy` arrays. (you need to go full native).

---

<Title level={3}>The gist</Title>

To be efficient your code must be **statically interpretable**.

This means that:

1. The engine will have **no hard decisions** to make
2. And will safely choose the most aggressive optimization paths

---

<Title level={3}>Rephrased</Title>

Optimizing JavaScript = squinting a little and pretending reaaaaaaally hard that:

1. The language has static typing.
2. That the language is low-level.

---

<Title affix="5.">References</Title>

Examples were taken from the following libraries:

* [mnemonist](https://yomguithereal.github.io/mnemonist): <small><em>yomguithereal.github.io/mnemonist</em></small>
* [graphology](https://graphology.github.io): <small><em>graphology.github.io</em></small>
* [sigma.js](http://sigmajs.org): <small><em>sigmajs.org</em></small>

---

# Thanks!
